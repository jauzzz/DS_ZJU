/*  分析“二分法”
    
    查找算法中的“二分法”是这样定义的：

    给定N个从小到大排好序的整数序列List[]，以及某待查找整数X，我们的目标是找到X在List中的下标。
    即若有List[i]=X，则返回i；否则返回-1表示没有找到。
    
    二分法是先找到序列的中点List[M]，与X进行比较，若相等则返回中点下标；
    否则，若List[M]>X，则在左边的子系列中查找X；若List[M]<X，则在右边的子系列中查找X。

    试写出算法的伪码描述，并分析最坏、最好情况下的时间、空间复杂度。
*/


/*
    最好情况：刚好中点就是这个值，一次找到，空间复杂度为 O(N)，时间复杂度为 1
    最坏情况：要一直找到最后才能找到，即计算要多少次才能找到这个值，2^i = n，即 i = logn，时间复杂度为 O(logn)，空间复杂度不变
*/
int Find(int l[], int s, int n, int x)
{
    int 序列中点;

    if (序列中点 == x)
    {
        return 序列中点;
    }

    if (序列中点 < x)
    {
        // 从右半段序列继续找
        Find(l, 序列中点, n, x);
    }
    else
    {
        // 从左半段序列继续找
        Find(l, s, 序列中点, x);
    }
}